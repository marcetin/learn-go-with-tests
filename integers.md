# Цели бројеви

**[Сав код за ово поглавље можете пронаћи овде](https://github.com/marcetin/nauci-go-sa-testovima/tree/main/integers)**

Цели бројеви раде онако како бисте очекивали. Напишимо функцију `Add` да испробамо ствари. Направите тест датотеку под називом `adder_test.go` и напишите овај код.

** Напомена: ** Го изворне датотеке могу имати само један `package` по директоријуму, побрините се да су ваше датотеке организоване одвојено. [Ево доброг објашњења о овоме.](https://dave.cheney.net/2014/12/01/five-suggestions-for-setting-up-a-go-project)

## Прво напишите тест

```go
package integers

import "testing"

func TestAdder(t *testing.T) {
	sum := Add(2, 2)
	expected := 4

	if sum != expected {
		t.Errorf("expected '%d' but got '%d'", expected, sum)
	}
}
```

Приметићете да користимо `%d` као низове формата, а не `%q`. То је зато што желимо да исписује цели број, а не низ.

Такође имајте на уму да више не користимо главни пакет, већ смо дефинисали пакет под називом `integers`, као што назив сугерише да ће ово груписати функције за рад са целим бројевима као што је` Add`.

## Покушајте и покрените тест

Покрените тест `go test`

Прегледајте грешку компилације

`./adder_test.go:6:9: undefined: Add`

## Напиши минималну количину кода за покретање теста и провери неуспешне резултате теста

Напишите довољно кода да задовољи компајлер _и то је све_ - не заборавите да желимо да проверимо да ли наши тестови из тачног разлога не успевају.

```go
package integers

func Add(x, y int) int {
	return 0
}
```

Када имате више аргумената истог типа \ (у нашем случају две целобројне \), уместо да имате `(x int, y int)`, можете га скратити на `(x, y int)`.

Сада покрените тестове и требало би да будемо сретни што тест исправно извештава шта није у реду.

`adder_test.go:10: expected '4' but got '0'`

Ако сте приметили, научили смо о _названој повраћајној вредности_ у [последњем](hello-world.md#one...last...refactor?) одељку, али овде не користе исти. Генерално би га требало користити када значење резултата није јасно из контекста, у нашем случају је прилично јасно да ће функција `Add` додати параметре. За више детаља можете упутити вики [тхис](https://github.com/golang/go/wiki/CodeReviewComments#named-result-parameters).

## Напишите довољно кода да прође

У најстрожем смислу ТДД-а, сада бисмо требали написати _минималну количину кода да би тест прошао_. Педантни програмер то може учинити

```go
func Add(x, y int) int {
	return 4
}
```

Ах хах! Опет осујећен, ТДД је лаж, зар не?

Могли бисмо да напишемо још један тест, са неким другачијим бројевима да присилимо тај тест да пропадне, али то се чини [игра мачке и миша](https://en.m.wikipedia.org/wiki/Cat_and_mouse).

Након што се боље упознамо са Го-овом синтаксом, увешћу технику која се зове *"Тестирање засновано на својствима"*, која ће зауставити досадне програмере и помоћи вам да пронађете грешке.

За сада, исправимо то исправно

```go
func Add(x, y int) int {
	return x + y
}
```

Ако поново покренете тестове, они би требали да прођу.

## Рефактор

У стварном коду нема много тога што овде заиста можемо побољшати.

Раније смо истражили како се именовањем повратног аргумента појављује у документацији, али и у уређивачима текста већине програмера.

Ово је сјајно јер помаже у употребљивости кода који пишете. Пожељно је да корисник може разумети употребу вашег кода само гледајући потпис типа и документацију.

Функцијама с коментарима можете додати документацију, а оне ће се појавити у Го Доц-у, баш као када погледате документацију стандардне библиотеке.

```go
// Add takes two integers and returns the sum of them.
func Add(x, y int) int {
	return x + y
}
```

### Примери

Ако заиста желите да пређете још који метар можете да направите [примере](https://blog.golang.org/examples). Много примера ћете наћи у документацији стандардне библиотеке.

Примери кода који се могу наћи изван базе кода, као што је датотека реадме, често застаревају и постају нетачни у поређењу са стварним кодом, јер се не проверавају.

Примери го извршавају се баш као и тестови, тако да можете бити сигурни да примери одражавају оно што код заправо ради.

Примери се компајлирају \ (и опционално извршавају \) као део пакета за тестирање.

Као и код типичних тестова, примери су функције које се налазе у датотекама `_test.go` пакета. Додајте следећу функцију `ExampleAdd` у датотеку `adder_test.go`.

```go
func ExampleAdd() {
	sum := Add(1, 5)
	fmt.Println(sum)
	// Output: 6
}
```

(Ако ваш уредник аутоматски не увози пакете за вас, корак компајлирања неће успети јер ће вам недостајати `import "fmt"` у `аддерadder_testтест.go`. Топло се препоручује да истражите како да поправите ову врсту грешака за вас аутоматски у било ком едитору који користите.)

Ако се ваш код промени тако да пример више није важећи, ваша изградња неће успети.

Покретањем пакета за тестирање пакета, можемо видети да се функција примера извршава без даљег договора од нас:

```bash
$ go test -v
=== RUN   TestAdder
--- PASS: TestAdder (0.00s)
=== RUN   ExampleAdd
--- PASS: ExampleAdd (0.00s)
```

Имајте на уму да се пример функције неће извршити ако уклоните коментар `// Output: 6`. Иако ће се функција компајлирати, неће се извршити.

Додавањем овог кода пример ће се појавити у документацији унутар `godoc`, чинећи ваш код још доступнијим.

Да бисте испробали ово, покрените `godoc -http=:6060` и идите на `http://localhost:6060/pkg/`

Овде ћете видети листу свих пакета у вашем `$GOPATH`, па под претпоставком да сте овај код написали негде попут `$GOPATH/src/github.com/{your_id}`, моћи ћете да пронађете свој пример документације.

Ако код са примерима објавите на јавном УРЛ-у, можете делити документацију кода на [pkg.go.dev](https://pkg.go.dev/). На пример, [овде](https://pkg.go.dev/github.com/marcetin/nauci-go-sa-testovima/integers/v2) је завршни АПИ за ово поглавље. Овај веб интерфејс вам омогућава да тражите документацију стандардних библиотечких пакета и независних пакета.

## Завршница

Шта смо покрили:

* Више праксе ТДД процеса рада
* Цели бројеви, сабирање
* Писање боље документације како би корисници нашег кода могли брзо да разумеју његову употребу
* Примери употребе нашег кода који се проверавају у оквиру наших тестова

# Убацивање пакета од којих зависи апликација

**[Сав код за ово поглавље можете пронаћи овде](https://github.com/marcetin/nauci-go-sa-testovima/tree/main/di)**

Претпоставља се да сте претходно прочитали одељак о структурама, јер ће за то бити потребно неко разумевање интерфејса.

Постоји _ много_ неспоразума око убризгавања зависности око програмске заједнице. Надам се да ће вам овај водич показати како

* Не треба вам оквир
* Не компликује ваш дизајн
* Олакшава тестирање
* Омогућава вам писање сјајних функција опште намене.

Желимо да напишемо функцију која поздравља некога, баш као што смо то урадили у поглављу поздрав света, али овог пута ћемо тестирати _активно штампање_.

Да резимирамо, ево како би та функција могла изгледати

```go
func Greet(name string) {
	fmt.Printf("Hello, %s", name)
}
```

Али како то можемо тестирати? Позивање `fmt.Printf` штампа се у стдоут, што је прилично тешко за нас да снимимо помоћу оквира за тестирање.

Оно што треба да урадимо је да можемо да **убризгамо**\(што је само измишљена реч за прелазак у\) зависност штампања.

**Наша функција не мора да брине**_**где**_** или **_**како се**_** врши приказ, па би требало да прихватимо **_**интерфејс**_**пре него конкретни тип.**

Ако то учинимо, онда можемо да променимо имплементацију тако да штампа на нешто што контролишемо како бисмо то могли да тестирамо. У „стварном животу“ бисте убризгали нешто што пише у стдоут.

Ако погледате изворни код `fmt.Printf``, можете видети начин на који се можемо прикључити

```go
// Враћа број написаних бајтова и било какву грешку приликом писања.
//func Printf(format string, a ...interface{}) (n int, err error) {
	return Fprintf(os.Stdout, format, a...)
}
```

Занимљиво! Испод хаубе `Printf` само позива` Fprintf` како пролази у `os.Stdout`.

Шта је тачно `os.Stdout`? Шта очекује `Fprintf` да му се проследи за први аргумент?

```go
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) {
	p := newPrinter()
	p.doPrintf(format, a)
	n, err = w.Write(p.buf)
	p.free()
	return
}
```

Један `io.Writer`

```go
type Writer interface {
	Write(p []byte) (n int, err error)
}
```

Из овога можемо закључити да `os.Stdout` имплементира` io.Writer`; `Printf` прослеђује `os.Stdout` у `Fprintf` који очекује `io.Writer`.

Како пишете више Го кода, овај интерфејс ће се често појављивати, јер је одличан интерфејс опште намене за „стављање ових података негде“.

Дакле, испод покривача знамо да на крају користимо `Writer` да негде пошаљемо свој поздрав. Искористимо ову постојећу апстракцију како бисмо учинили наш код тестираним и поновљивим.

## Прво напишите тест

```go
func TestGreet(t *testing.T) {
	buffer := bytes.Buffer{}
	Greet(&buffer, "Chris")

	got := buffer.String()
	want := "Hello, Chris"

	if got != want {
		t.Errorf("got %q want %q", got, want)
	}
}
```

Тип `Buffer` из пакета` bytes` имплементира интерфејс `Writer`, јер има метод `Write(p []byte) (n int, err error)`.

Тако ћемо га користити у нашем тесту за слање као нашег `Вритер-а`, а затим можемо проверити шта му је написано након што позовемо` Greet`

## Покушајте да покренете тест

Тест се неће компајлирати

```text
./di_test.go:10:7: too many arguments in call to Greet
    have (*bytes.Buffer, string)
    want (string)
```

## Напиши минималну количину кода за покретање теста и провери неуспешне резултате теста

_Пратите компајлер_ и решите проблем.

```go
func Greet(writer *bytes.Buffer, name string) {
	fmt.Printf("Hello, %s", name)
}
```

`Hello, Chris di_test.go:16: got '' want 'Hello, Chris'`

Тест није успео. Приметите да се име штампа, али ће нестати.

## Напишите довољно кода да прође

Помоћу писца пошаљите поздрав у бафер у нашем тесту. Запамтите да је `fmt.Fprintf` сличан` fmt.Printf`, али уместо тога узима `Writer` коме ће послати низ, док је` fmt.Printf` подразумевано стдоут.

```go
func Greet(writer *bytes.Buffer, name string) {
	fmt.Fprintf(writer, "Hello, %s", name)
}
```

Тест сада пролази успешно.

## Рефактор

Раније нам је компајлер рекао да пренесемо показивач на `bytes.Buffer`. Ово је технички исправно, али не баш корисно.

Да бисте то демонстрирали, покушајте да повежете функцију `Greet` у апликацију Го где желимо да се штампа у стдоут.

```go
func main() {
	Greet(os.Stdout, "Elodie")
}
```

`./di.go:14:7: cannot use os.Stdout (type *os.File) as type *bytes.Buffer in argument to Greet`

Као што је раније речено, `fmt.Fprintf` вам омогућава да проследите датотеку `io.Writer` коју познајемо и као `os.Stdout` и `bytes.Buffer`.

Ако променимо наш код тако да користи интерфејс опште намене, сада га можемо користити и у тестовима и у нашој апликацији.

```go
package main

import (
    "fmt"
    "os"
    "io"
)

func Greet(writer io.Writer, name string) {
    fmt.Fprintf(writer, "Hello, %s", name)
}

func main() {
	Greet(os.Stdout, "Elodie")
}
```

## Више о ио.Вритер

На која друга места можемо да упишемо податке помоћу `io.Writer`? Колико је општа сврха наша функција `Greet`?

### Интернет

Покрените следеће

```go
package main

import (
    "fmt"
    "io"
    "log"
    "net/http"
)

func Greet(writer io.Writer, name string) {
    fmt.Fprintf(writer, "Hello, %s", name)
}

func MyGreeterHandler(w http.ResponseWriter, r *http.Request) {
    Greet(w, "world")
}

func main() {
    log.Fatal(http.ListenAndServe(":5000", http.HandlerFunc(MyGreeterHandler)))
}
```

Покрените програм и идите на [http://localhost:5000](http://localhost:5000). Видећете да се користи функција поздрава.

ХТТП сервери ће бити обрађени у каснијем поглављу, зато не брините превише о детаљима.

Када напишете ХТТП руковатељ, добићете `http.ResponseWriter` и `http.Request` који су коришћени за подношење захтева. Када имплементирате сервер, _записујете_ свој одговор помоћу програма за писање.

Вероватно можете претпоставити да `http.ResponseWriter` такође имплементира `io.Writer` па смо зато могли поново да користимо нашу функцију `Greet` унутар нашег обрађивача.

## Окончање

Наш први круг кода није било лако тестирати јер је записао податке негде где нисмо могли да контролишемо.

_Мотивисани нашим тестовима_ извршили смо факторизацију кода како бисмо могли контролисати _где_ подаци су записани **убризгавањем пакета од којих зависи апликација** која нам је омогућила да:

* ** Тестирајте наш код** Ако не можете лако да тестирате функцију, то је обично због зависности које су чврсто повезане у функцију _ или_ глобално стање. Ако, на пример, имате глобално спремиште везе са базом података које користи нека врста сервисног слоја, вероватно ће бити тешко тестирати и они ће се споро покретати. ДИ ће вас мотивисати да убризгате у зависност базе података \ (путем интерфејса \), коју затим можете исмејати нечим што можете контролисати у својим тестовима.
* ** Одвојите нашу забринутост**, раздвајањем _куда подаци иду_ од _како их генерирати_. Ако се икада осећате као да метода / функција има превише одговорности \ (генерисање података _ и_ уписивање у дб? Руковање ХТТП захтевима _ и_ извршавање логике на нивоу домена? \) ДИ ће вероватно бити алат који вам треба.
* ** Омогућите поновну употребу нашег кода у различитим контекстима **Први „нови“ контекст у којем се наш код може користити је унутар тестова. Али даље, ако неко жели да испроба нешто ново са вашом функцијом, може убризгати сопствене зависности.

### Шта је са мокингом? Чујем да вам то треба за ДИ, а такође је и зло

Исмевање ће бити детаљно обрађено касније \(и није зло\). Подругљиво користите да бисте стварне ствари које убризгате заменили претвараном верзијом коју можете да контролишете и прегледате у тестовима. У нашем случају, стандардна библиотека је имала нешто спремно за употребу.

### Го стандардна библиотека је заиста добра, треба времена да је проучите

Упознавањем интерфејса `io.Writer` у могућности смо да користимо `bytes.Buffer` у нашем тесту као `Writer`, а затим можемо користити и друге` Writer`-ове из стандардне библиотеке да бисмо користили нашу функцију у апликација командне линије или на веб серверу.

Што сте више упознати са стандардном библиотеком, то ћете више видети ове интерфејсе опште намене, које затим можете поново користити у свом коду како бисте свој софтвер учинили поновним за употребу у одређеном контексту.

На овај пример снажно утиче поглавље у [Програмски језик Го](https://www.amazon.co.uk/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440), па ако сте уживали у овоме иди купи!

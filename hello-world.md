# Здраво Свете

**[Сав код за ово поглавље можете пронаћи овде](https://github.com/marcetin/nauci-go-sa-testovima/tree/main/hello-world)**

Традиционално је да то буде ваш први програм на новом језику [Здраво, Свете](https://en.m.wikipedia.org/wiki/%22Hello,_World!%22_program).

- Create a folder wherever you like
- У њу ставите нову датотеку под називом `hello.go` и у њу ставите следећи код

```go
package main

import "fmt"

func main() {
	fmt.Println("Здраво, Свете")
}
```

Да бисте га покренули, откуцајте `go run hello.go`.

## Како то ради

Када напишете програм у Го-у, имаћете `main` пакет дефинисан са` main` функцијама унутар њега. Пакети су начини за груписање сродног Го кода.

Кључна реч `func` је начин на који дефинишете функцију са именом и телом.

Са `import "fmt"` увозимо пакет који садржи функцију `Println` коју користимо за штампање.

## Како тестирати

Како се ово тестира? Добро је одвојити свој „доменски“ код од спољног света \ (нуспојаве \). `fmt.Println` је нежељени ефекат \ (штампање у стдоут \), а низ који шаљемо је наша домена.

Па хајде да раздвојимо ове бриге како би било лакше тестирати

```go
package main

import "fmt"

func Hello() string {
	return "Здраво, Свете"
}

func main() {
	fmt.Println(Hello())
}
```

Поново смо креирали нову функцију са `func`, али овог пута смо у дефиницију додали још једну кључну реч` string`. То значи да ова функција враћа `string`.

Сада креирајте нову датотеку под називом `hello_test.go` где ћемо написати тест за нашу функцију` Hello`

```go
package main

import "testing"

func TestHello(t *testing.T) {
	got := Hello()
	want := "Hello, world"

	if got != want {
		t.Errorf("got %q want %q", got, want)
	}
}
```

## Го модули?

Следећи корак је покретање тестова. Унесите `go test` у свом терминалу. Ако тестови прођу, вероватно користите старију верзију Го-а. Међутим, ако користите Го 1.16 или новију верзију, тестови се вероватно неће покретати. Уместо тога, видећете поруку о грешци попут ове у терминалу:

```shell
$ go test
go: cannot find main module; see 'go help modules'
```

У чему је проблем? У речи, [модули](https://blog.golang.org/go116-module-changes). Срећом, проблем је лако решити. Унесите `go mod init hello` у свом терминалу. То ће створити нову датотеку са следећим садржајем:

```go
module hello

go 1.16
```

Ова датотека говори алаткама `go` основне информације о вашем коду. Ако планирате да дистрибуирате своју апликацију, навели бисте где је код доступан за преузимање, као и информације о пакетима о којима зависи апликација. За сада је датотека вашег модула минимална и можете је тако и оставити. Да бисте прочитали више о модулима, [референцу можете погледати у документацији Голанг](https://golang.org/doc/modules/gomod-ref). Сад се можемо вратити тестирању и учењу Го-а јер би тестови требали да се покрећу, чак и на Го 1.16.

У будућим поглављима мораћете да покренете `go mod init НЕКОИМЕ` у свакој новој фасцикли пре покретања команди попут `go test` или `go build`.

## Повратак на тестирање

Покрените `go test` на свом терминалу. Требало је да прође! Само да бисте проверили, покушајте намерно да прекинете тест променом низа `want`.

Приметите како нисте морали да бирате између више оквира за тестирање, а затим смислите како да инсталирате. Све што вам је потребно уграђено је у језик, а синтакса је иста као и остатак кода који ћете написати.

### Писање тестова

Писање теста је попут писања функције, са неколико правила

* То мора бити у датотеци са именом попут `xxx_test.go`
* Тест функција мора започети речју `Test`
* Тест функција узима само један аргумент `t *testing.T`
* Да бисте користили тип `*testing.T`, морате `import "testing"`, као што смо то урадили са` fmt` у другој датотеци

За сада је довољно да знате да је ваше `t` типа `*testing.T` ваше "закачење" за оквир тестирања, па можете да радите ствари попут `t.Fail()` када желите да не успете.

Обрадили смо неке нове теме:

#### `if`
`if` искази у Го-у су слични као у другим програмским језицима.

#### Декларисање променљивих

Декларишемо неке променљиве синтаксом `varName := value`, што нам омогућава да поново користимо неке вредности у нашем тесту за читљивост.

#### `t.Errorf`

Позивамо `Errorf` _метод_ на нашем `t` који ће исписати поруку и пасти на тесту. `f` означава формат који нам омогућава да направимо низ са вредностима уметнутим у вредности резервисаног места `%q`. Када направите тест неуспешним, требало би да буде јасно како то функционише.

Можете прочитати више о низовима чувара места у [fmt go doc](https://golang.org/pkg/fmt/#hdr-Printing). За тестове `%q` је веома користан јер ваше вредности умотава у двоструке наводнике.

We will later explore the difference between methods and functions.

### Go doc

Another quality of life feature of Go is the documentation. You can launch the docs locally by running `godoc -http :8000`. If you go to [localhost:8000/pkg](http://localhost:8000/pkg) you will see all the packages installed on your system.

The vast majority of the standard library has excellent documentation with examples. Navigating to [http://localhost:8000/pkg/testing/](http://localhost:8000/pkg/testing/) would be worthwhile to see what's available to you.

If you don't have `godoc` command, then maybe you are using the newer version of Go (1.14 or later) which is [no longer including `godoc`](https://golang.org/doc/go1.14#godoc). You can manually install it with `go get golang.org/x/tools/cmd/godoc`.

### Здраво ТИ

Сад кад имамо тест, можемо безбедно да га поновимо на нашем софтверу.

У последњем примеру написали смо тест _након_ што је код написан само да бисте могли добити пример како написати тест и декларисати функцију. Од овог тренутка ћемо _прво писање тестова_.

Наш следећи услов је да нам одредимо примаоца честитке.

Почнимо са хватањем ових захтева у тесту. Ово је основни развој вођен тестом и омогућава нам да се уверимо да наш тест _заправо_ тестира оно што желимо. Када ретроспективно пишете тестове, постоји ризик да ваш тест настави да пролази, чак и ако код не ради како је предвиђено.

```go
package main

import "testing"

func TestHello(t *testing.T) {
	got := Hello("Chris")
	want := "Hello, Chris"

	if got != want {
		t.Errorf("got %q want %q", got, want)
	}
}
```

Сада покрените `go test`, требало би да имате грешку у компилацији

```text
./hello_test.go:6:18: too many arguments in call to Hello
    have (string)
    want ()
```

Када користите статички куцани језик попут Го, важно је _слушати компајлер_. Преводник разуме како ваш код треба да се спаја и ради тако да не морате.

У овом случају компајлер вам говори шта треба да урадите да бисте наставили. Морамо да променимо нашу функцију `Hello` да бисмо прихватили аргумент.

Уредите функцију `Hello` како бисте прихватили аргумент типа стринг

```go
func Hello(name string) string {
	return "Hello, world"
}
```

Ако поново покушате да покренете тестове, `hello.go` неће успети да се компајлира јер не предајете аргумент. Пошаљите у „свет“ да то прође.

```go
func main() {
	fmt.Println(Hello("world"))
}
```

Сада када покренете тестове, требало би да видите нешто слично

```text
hello_test.go:10: got 'Hello, world' want 'Hello, Chris''
```

Напокон имамо програм за компајлирање, али он не испуњава наше захтеве према тесту.

Направимо да тест прође помоћу аргумента наме и спојимо га са `Hello,`

```go
func Hello(name string) string {
	return "Hello, " + name
}
```

Када покренете тестове, они би сада требали да прођу. Обично као део ТДД циклуса сада бисмо требали _рефактор_.

### Напомена о контроли извора

У овом тренутку, ако користите контролу извора \ (што би требало! \), Ја бих
`commit` код какав је. Имамо радни софтвер подржан тестом.

Ипак _не бих желео_ да пуштам на мастер, јер следеће планирам да га преправљам. То је лепо да се обавежете у овом тренутку у случају да на неки начин упаднете у неред са рефакторингом - увек се можете вратити на радну верзију.

Овде нема много тога за рефакторирање, али можемо увести још једну језичку функцију, _константе_.

### Константе

Константе су дефинисане овако

```go
const englishHelloPrefix = "Hello, "
```

Сада можемо да преправимо наш код

```go
const englishHelloPrefix = "Hello, "

func Hello(name string) string {
	return englishHelloPrefix + name
}
```

Након рефакторирања, поново покрените тестове како бисте били сигурни да нисте ништа покварили.

Константе би требале побољшати перформансе ваше апликације јер вам штеди стварање инстанце `"Hello, "` стринг сваки пут када се позове `Hello`.

Да будемо јасни, повећање перформанси је невероватно занемарљиво за овај пример! Али вреди размислити о стварању константи које ће ухватити значење вредности, а понекад и да помогну учинку.

## Здраво, свете ... опет

Следећи захтев је када се наша функција позива са празним низом, а она подразумевано исписује "Hello, World", уместо "Hello, ".

Започните са писањем новог неуспелог теста

```go
func TestHello(t *testing.T) {

	t.Run("saying hello to people", func(t *testing.T) {
		got := Hello("Chris")
		want := "Hello, Chris"

		if got != want {
			t.Errorf("got %q want %q", got, want)
		}
	})

	t.Run("say 'Hello, World' when an empty string is supplied", func(t *testing.T) {
		got := Hello("")
		want := "Hello, World"

		if got != want {
			t.Errorf("got %q want %q", got, want)
		}
	})

}
```

Овде уводимо још један алат у наш арсенал тестирања, субтестове. Понекад је корисно груписати тестове око „неке ствари“, а затим имати подтестове који описују различите сценарије.

Предност овог приступа је што можете поставити заједнички код који се може користити у осталим тестовима.

Понавља се код када проверимо да ли је порука оно што очекујемо.

Препрабљање није само у вези са производним кодом!

Важно је да ваши тестови _буду јасне спецификације_ онога што код треба да уради.

Можемо и треба да преправимо своје тестове.

```go
func TestHello(t *testing.T) {

	assertCorrectMessage := func(t testing.TB, got, want string) {
		t.Helper()
		if got != want {
			t.Errorf("got %q want %q", got, want)
		}
	}

	t.Run("saying hello to people", func(t *testing.T) {
		got := Hello("Chris")
		want := "Hello, Chris"
		assertCorrectMessage(t, got, want)
	})

	t.Run("empty string defaults to 'World'", func(t *testing.T) {
		got := Hello("")
		want := "Hello, World"
		assertCorrectMessage(t, got, want)
	})

}
```

Шта смо ми овде урадили?

Нашу тврдњу смо преобликовали у функцију. Ово смањује дуплирање и побољшава читљивост наших тестова. У програму Го можете декларисати функције унутар других функција и доделити их променљивим. Тада их можете позвати, баш као и уобичајене функције. Морамо да прођемо у `t *testing.T` да бисмо могли да кажемо да тест код не успе када то треба.

За помоћне функције, добра идеја је прихватити `testing.TB` који је интерфејс који задовољава `*testing.T` и `*testing.B`, тако да помоћне функције можете позвати из теста или референтне вредности .

`t.Helper()` је потребан да би тест пакету рекао да је овај метод помоћник. Радећи ово када закаже, пријављени број линије биће у нашем _функцијском позиву_, а не у нашем помоћнику за тестирање. Ово ће помоћи другим програмерима да лакше пронађу проблеме. Ако и даље не разумете, коментаришите га, направите тест неуспешан и посматрајте резултат теста. Коментари у Го-у су одличан начин да додате додатне информације у свој код, или у овом случају, брзи начин да кажете компајлеру да занемари ред. Можете `прокоментарисати` т.Хелпер () `код додавањем две косе црте` // `на почетку реда. Требало би да видите како та линија постаје сива или се мења у другу боју од остатка вашег кода да бисте означили да је сада коментарисан.

Сад кад имамо добро написан тест неуспеха, поправимо код помоћу `if`.

```go
const englishHelloPrefix = "Hello, "

func Hello(name string) string {
	if name == "" {
		name = "World"
	}
	return englishHelloPrefix + name
}
```

Ако покренемо тестове, требало би да видимо да задовољава нови захтев и да нисмо случајно прекршили остале функције.

### Повратак на контролу извора

Сада смо задовољни кодом који бих изменио у претходном урезивању, тако да само
проверите дивну верзију нашег кода са својим тестом.

### Дисциплина

Идемо поново преко циклуса

* Напишите тест
* Нека компајлер прође
* Покрените тест, уверите се да не успе и проверите да ли је порука о грешци значајна
* Напишите довољно кода да тест прође
* Рефактор

На први поглед, ово може изгледати досадно, али држање повратне спреге је важно.

Не само да осигурава да имате _релевантне тестове_, већ и осигурава _израду доброг софтвера_ рефакторирањем са сигурношћу тестова.

Видети неуспех теста је важна провера јер вам такође омогућава да видите како изгледа порука о грешци. Као програмеру може бити веома тешко радити са кодном базом када неуспели тестови не дају јасну идеју у чему је проблем.

Ако осигурате да су тестови _брзи_ и подесите алате тако да је покретање тестова једноставно, можете да уђете у стање протока приликом писања кода.

Не писањем тестова обавезујете се да ћете ручно проверавати код покретањем софтвера који прекида ваше стање протока и нећете штедети време, посебно дугорочно.

## Настави! Више захтева

Боже мој, имамо више захтева. Сада морамо подржати други параметар, који наводи језик поздрава. Ако се преда језик који не препознајемо, само подразумевано поставите енглески.

Требали бисмо бити сигурни да можемо да користимо ТДД за лако откривање ове функције!

Напишите тест за корисника који пролази шпански. Додајте га у постојећи пакет.
```go
	t.Run("in Spanish", func(t *testing.T) {
		got := Hello("Elodie", "Spanish")
		want := "Hola, Elodie"
		assertCorrectMessage(t, got, want)
	})
```

Запамтите да не варате! _Прво тестирајте_. Када покушате да покренете тест, компајлер _би се требао_ жалити јер зовете `Hello` са два аргумента, а не једним.

```text
./hello_test.go:27:19: too many arguments in call to Hello
    have (string, string)
    want (string)
```

Решите проблеме са компилацијом додавањем још једног аргумента низа у `Hello`

```go
func Hello(name string, language string) string {
	if name == "" {
		name = "World"
	}
	return englishHelloPrefix + name
}
```

Када поново покушате да покренете тест, он ће се жалити што није проследио довољно аргумената у `Hello` у осталим тестовима и у `hello.go`

```text
./hello.go:15:19: not enough arguments in call to Hello
    have (string)
    want (string, string)
```

Поправите их пролазећи кроз празне низове. Сада би сви ваши тестови требало да компајлирају _и_ прођу, осим нашег новог сценарија

```text
hello_test.go:29: got 'Hello, Elodie' want 'Hola, Elodie'
```

Овде можемо да употребимо `if` да бисмо проверили да ли је језик једнак "шпанском" и ако је тако променимо поруку

```go
func Hello(name string, language string) string {
	if name == "" {
		name = "World"
	}

	if language == "Spanish" {
		return "Hola, " + name
	}

	return englishHelloPrefix + name
}
```

Тестови би сада требало да прођу.

Сада је време за _рефакторисање_. У коду бисте требали видети неке проблеме, „магичне“ низове, од којих се неки понављају. Покушајте сами и рефакторишите га, уз сваку промену обавезно поново покрените тестове како бисте били сигурни да ваше рефакторирање ништа не крши.

```go
const spanish = "Spanish"
const englishHelloPrefix = "Hello, "
const spanishHelloPrefix = "Hola, "

func Hello(name string, language string) string {
	if name == "" {
		name = "World"
	}

	if language == spanish {
		return spanishHelloPrefix + name
	}

	return englishHelloPrefix + name
}
```

### Француски

* Напишите тест тврдећи да ако уђете у `„француски“`, добићете `"Bonjour, "`
* Ако не успе, проверите да ли је порука о грешци лака за читање
* Направите најмању разумну промену кода

Можда сте написали нешто што отприлике изгледа овако

```go
func Hello(name string, language string) string {
	if name == "" {
		name = "World"
	}

	if language == spanish {
		return spanishHelloPrefix + name
	}

	if language == french {
		return frenchHelloPrefix + name
	}

	return englishHelloPrefix + name
}
```

## `switch`

Када имате пуно израза `if` који проверавају одређену вредност, уобичајено је да се уместо тога користи израз` switch`. Можемо користити `switch` за рефакторирање кода како бисмо га учинили лакшим за читање и проширивим ако касније желимо да додамо више језичке подршке

```go
func Hello(name string, language string) string {
	if name == "" {
		name = "World"
	}

	prefix := englishHelloPrefix

	switch language {
	case french:
		prefix = frenchHelloPrefix
	case spanish:
		prefix = spanishHelloPrefix
	}

	return prefix + name
}
```

Напишите тест да бисте сада укључили поздрав на језику по вашем избору и требали бисте видети како је једноставно проширити нашу функцију _амазинг_.

### један ... последњи ... рефактор?

Можете тврдити да наша функција можда постаје мало већа. Најједноставнији рефактор за ово био би издвајање неке функционалности у другу функцију.

```go
func Hello(name string, language string) string {
	if name == "" {
		name = "World"
	}

	return greetingPrefix(language) + name
}

func greetingPrefix(language string) (prefix string) {
	switch language {
	case french:
		prefix = frenchHelloPrefix
	case spanish:
		prefix = spanishHelloPrefix
	default:
		prefix = englishHelloPrefix
	}
	return
}
```

Неколико нових концепата:

* У нашем потпису функције направили смо _названу повратну вредност_ `(prefix string)`.
* Ово ће створити променљиву која се назива `prefix` у вашој функцији.
    * Биће му додељена вредност "нула". Ово зависи од типа, на пример `int`с су 0, а за `string` је `""`.
        * Можете вратити све на шта је постављено тако што ћете само позвати `return`, а не `return prefix`.
    * Ово ће се приказати у документу Го за вашу функцију, тако да намера вашег кода може бити јаснија.
* `default` у случају прекидача биће разгранато на ако се не подудара ниједан други израз` case`.
* Назив функције почиње малим словом. У Го-у јавне функције почињу великим словом, а приватне малим словом. Не желимо да унутрашњост нашег алгоритма буде изложена свету, па смо ову функцију учинили приватном.

## Завршница

Ко је знао да можеш толико извући из `Hello, world`?

До сада бисте требали мало разумети:

### Неке Гоове синтаксе около

* Писање тестова
* Декларисање функција са аргументима и типовима повратка
* `if`, `const` и `switch`
* Декларисање променљивих и константи

### Процес ТДД и _зашто_ кораци су важни

* _Напишите тест неуспеха и уверите се да није успео_, тако да знамо да смо написали _релевантни_ тест за наше захтеве и видели да он даје _ лако разумљив опис неуспеха_
* Писање најмање количине кода да би прошло како бисмо знали да имамо радни софтвер
* _Тада_ рефактор, потпомогнут сигурношћу наших тестова како би се осигурало да имамо добро израђен код са којим је лако радити

У нашем случају прешли смо из `Хелло ()` у `Хелло (" наме ")` у `Хелло (" наме "," Френцх ")` у малим, лако разумљивим корацима.

Ово је наравно тривијално у поређењу са софтвером из "стварног света", али принципи и даље стоје. ТДД је вештина којој је потребна пракса да би се развила, али рашчлањивањем проблема на мање компоненте које можете да тестирате, биће вам много лакше писати софтвер.

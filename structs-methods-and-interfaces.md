# Структуре, методе и интерфејси

**[Сав код за ово поглавље можете пронаћи овде](https://github.com/marcetin/nauci-go-sa-testovima/tree/main/structs)**

Претпоставимо да нам је потребан геометријски код за израчунавање опсега правоугаоника са задатом висином и ширином. Можемо написати функцију `Perimeter (width float64, height float64)`, где је `float64` за бројеве са помичном зарезом попут` 123.45`.

ТДД циклус би вам до сада требао бити прилично познат.

## Прво напишите тест

```go
func TestPerimeter(t *testing.T) {
    got := Perimeter(10.0, 10.0)
    want := 40.0

    if got != want {
        t.Errorf("got %.2f want %.2f", got, want)
    }
}
```

Приметили сте нови формат формата? `f` је за наш `float64`, а `.2` значи испис 2 децимале.

## Покушајте да покренете тест

`./shapes_test.go:6:9: undefined: Perimeter`

## Напишите минималну количину кода за покретање теста и проверите неуспешне резултате теста

```go
func Perimeter(width float64, height float64) float64 {
    return 0
}
```

Results in `shapes_test.go:10: got 0.00 want 40.00`.

## Напишите довољно кода да прође

```go
func Perimeter(width float64, height float64) float64 {
    return 2 * (width + height)
}
```

За сада тако лако. Сада креирајмо функцију која се назива `Area(width, height float64)` која враћа површину правоугаоника.

Покушајте то учинити сами, пратећи ТДД циклус.

Требали бисте завршити са оваквим тестовима

```go
func TestPerimeter(t *testing.T) {
    got := Perimeter(10.0, 10.0)
    want := 40.0

    if got != want {
        t.Errorf("got %.2f want %.2f", got, want)
    }
}

func TestArea(t *testing.T) {
    got := Area(12.0, 6.0)
    want := 72.0

    if got != want {
        t.Errorf("got %.2f want %.2f", got, want)
    }
}
```

И овакав код

```go
func Perimeter(width float64, height float64) float64 {
    return 2 * (width + height)
}

func Area(width float64, height float64) float64 {
    return width * height
}
```

## Рефактор

Функцијама бисмо могли дати конкретнија имена попут `RectangleArea`. Уређеније решење је дефинисање сопственог _типа_ под називом `Rectangle` који за нас садржи овај концепт.

Можемо створити једноставан тип користећи **структуру**. [Структура](https://golang.org/ref/spec#Struct_types) је само именована колекција поља у коју можете да сместите податке.

Прогласите структуру попут ове

```go
type Rectangle struct {
    Width float64
    Height float64
}
```

Сада рефакторизирамо тестове да би користили `Rectangle` уместо обичних` float64`.

```go
func TestPerimeter(t *testing.T) {
    rectangle := Rectangle{10.0, 10.0}
    got := Perimeter(rectangle)
    want := 40.0

    if got != want {
        t.Errorf("got %.2f want %.2f", got, want)
    }
}

func TestArea(t *testing.T) {
    rectangle := Rectangle{12.0, 6.0}
    got := Area(rectangle)
    want := 72.0

    if got != want {
        t.Errorf("got %.2f want %.2f", got, want)
    }
}
```

Не заборавите да покренете тестове пре него што покушате да их поправите. Тестови би требали показати корисну грешку попут

```text
./shapes_test.go:7:18: not enough arguments in call to Perimeter
    have (Rectangle)
    want (float64, float64)
```

Пољима структуре можете приступити синтаксом `myStruct.field`.

Промените две функције да бисте поправили тест.

```go
func Perimeter(rectangle Rectangle) float64 {
    return 2 * (rectangle.Width + rectangle.Height)
}

func Area(rectangle Rectangle) float64 {
    return rectangle.Width * rectangle.Height
}
```

Надам се да ћете се сложити да прослеђивање `Rectangle` функцији јасније преноси нашу намеру, али има више користи од коришћења структура које ћемо касније обрадити.

Наш следећи захтев је да напишемо функцију `Area` за кругове.

## Прво напишите тест

```go
func TestArea(t *testing.T) {

    t.Run("rectangles", func(t *testing.T) {
        rectangle := Rectangle{12, 6}
        got := Area(rectangle)
        want := 72.0

        if got != want {
            t.Errorf("got %g want %g", got, want)
        }
    })

    t.Run("circles", func(t *testing.T) {
        circle := Circle{10}
        got := Area(circle)
        want := 314.1592653589793

        if got != want {
            t.Errorf("got %g want %g", got, want)
        }
    })

}
```

Као што видите, `f` је са добрим разлогом замењен `g`.
Употребом `g` исписат ће се прецизнији децимални број у поруци о грешци \ ([фмт опције](https://golang.org/pkg/fmt/)\).
На пример, користећи полупречник 1,5 у прорачуну површине круга, `f` би показао `7.068583`, док би `g` приказао `7.0685834705770345`.

## Покушајте да покренете тест

`./shapes_test.go:28:13: undefined: Circle`

## Напишите минималну количину кода за покретање теста и проверите неуспешне резултате теста

Морамо да дефинишемо свој тип `Circle`.

```go
type Circle struct {
    Radius float64
}
```

Покушајте поново да покренете тестове

`./shapes_test.go:29:14: cannot use circle (type Circle) as type Rectangle in argument to Area`

Неки програмски језици омогућавају вам да урадите нешто слично:

```go
func Area(circle Circle) float64 { ... }
func Area(rectangle Rectangle) float64 { ... }
```

Али не можете у Го

`./shapes.go:20:32: Area redeclared in this block`

Имамо два избора:

* Можете имати функције са истим именом декларисане у различитим _пакетима_. Тако бисмо могли да направимо нашу `Area(Circle)` у новом пакету, али то овде делује претјерано.
* Уместо тога можемо да дефинишемо [_методе_](https://golang.org/ref/spec#Method_declarations) на нашим ново дефинисаним типовима.

### Шта су методе?

До сада смо писали само _функције_, али користили смо неке методе. Када зовемо `t.Errorf`, позивамо методу` Errorf` на инстанци нашег `t` \(`testing.T`\).

Метода је функција са пријемником.
Декларација методе веже идентификатор, име методе, за методу и повезује методу са основним типом примаоца.

Методе су врло сличне функцијама, али се позивају позивајући их на инстанци одређеног типа. Тамо где можете само позвати функције где год желите, као што је `Area(rectangle)`, методе можете позивати само на "стварима".

Пример ће вам помоћи, па хајде да прво променимо тестове да бисмо уместо њих позвали методе, а затим поправили код.


```go
func TestArea(t *testing.T) {

    t.Run("rectangles", func(t *testing.T) {
        rectangle := Rectangle{12, 6}
        got := rectangle.Area()
        want := 72.0

        if got != want {
            t.Errorf("got %g want %g", got, want)
        }
    })

    t.Run("circles", func(t *testing.T) {
        circle := Circle{10}
        got := circle.Area()
        want := 314.1592653589793

        if got != want {
            t.Errorf("got %g want %g", got, want)
        }
    })

}
```

Ако покушамо да покренемо тестове, добићемо

```text
./shapes_test.go:19:19: rectangle.Area undefined (type Rectangle has no field or method Area)
./shapes_test.go:29:16: circle.Area undefined (type Circle has no field or method Area)
```

> тип Circle нема поље или методу Area

Желео бих да поновим како је сјајан преводилац овде. Толико је важно да одвојите време да полако прочитате поруке о грешкама које добијате, дугорочно ће вам помоћи.

## Напишите минималну количину кода за покретање теста и проверите неуспешне резултате теста

Хајде да додамо неке методе нашим типовима

```go
type Rectangle struct {
    Width  float64
    Height float64
}

func (r Rectangle) Area() float64  {
    return 0
}

type Circle struct {
    Radius float64
}

func (c Circle) Area() float64  {
    return 0
}
```

Синтакса за декларисање метода је скоро иста као и функције и то зато што су толико сличне. Једина разлика је синтакса методе пријемник `func (receiverName ReceiverType) MethodName(args)`.

Када се ваш метод позове за променљиву тог типа, добићете референцу на његове податке путем променљиве `receiverName`. У многим другим програмским језицима то се ради имплицитно и пријемнику приступате путем `this`.

У Го је конвенција да променљива пријемника буде прво слово типа.

```go
r Rectangle
```

Ако покушате да поново покренете тестове, они би сада требали да их компајлирају и да вам дају неке неуспешне резултате.

## Напишите довољно кода да прође

Сада учинимо да наши тестови правоугаоника прођу поправљајући нашу нову методу

```go
func (r Rectangle) Area() float64  {
    return r.Width * r.Height
}
```

Ако поново покренете тестове, тестови правоугаоника би требало да прођу, али круг и даље не би успео.

Да би функција `Area` круга прошла, посудићемо константу `Pi` из пакета `math` (не заборавите да је увезете \).


```go
func (c Circle) Area() float64  {
    return math.Pi * c.Radius * c.Radius
}
```

## Рефактор

Наши тестови се дуплицирају.

Све што желимо је да узмемо колекцију _схапес_, на њима позовемо методу `Area()`, а затим проверимо резултат.

Желимо да имамо могућност да напишемо неку врсту функције `checkArea` којој можемо проследити и `Rectangle` и `Circle`, али не успевамо да компајлирамо ако покушамо да унесемо нешто што није облик.

Уз Го, ову намеру можемо кодификовати са **интерфејсима**.

[Интерфејси](https://golang.org/ref/spec#Interface_types) су врло моћан концепт у статички откуцаним језицима као што је Го, јер вам омогућавају да направите функције које се могу користити са различитим типовима и да истовремено створите високо одвојени код и даље одржавајући сигурност типа.

Уведимо ово рефакторисањем наших тестова.

```go
func TestArea(t *testing.T) {

    checkArea := func(t testing.TB, shape Shape, want float64) {
        t.Helper()
        got := shape.Area()
        if got != want {
            t.Errorf("got %g want %g", got, want)
        }
    }

    t.Run("rectangles", func(t *testing.T) {
        rectangle := Rectangle{12, 6}
        checkArea(t, rectangle, 72.0)
    })

    t.Run("circles", func(t *testing.T) {
        circle := Circle{10}
        checkArea(t, circle, 314.1592653589793)
    })

}
```

Стварамо помоћну функцију као у другим вежбама, али овог пута тражимо да се унесе `Shape`. Ако ово покушамо назвати нечим што није облик, неће се компајлирати.

Како нешто постаје облик? Го кажемо Го шта `Shape` користи декларацију интерфејса

```go
type Shape interface {
    Area() float64
}
```

Стварамо нови `type` баш као што смо то радили са `Rectangle` и `Circle`, али овај пут то је `interface`, а не `struct`.

Када ово додате у код, тестови ће проћи.

### Чекај шта?

Ово се прилично разликује од интерфејса у већини других програмских језика. Обично морате написати код да бисте рекли `My type Foo implements interface Bar`.

Али у нашем случају

* `Rectangle` има методу која се назива `Area` која враћа `float64` тако да задовољава интерфејс `Shape`
* `Circle` има методу која се назива `Ареа` која враћа `float64` тако да задовољава интерфејс `Shape`
* `string` нема такав метод, тако да не задовољава интерфејс
* итд.

У Го **резолуција интерфејса је имплицитна**. Ако се тип који проследите подудара са оним што тражи интерфејс, компајлираће се.

### Одвајање

Приметите како наш помагач не треба да се бави тиме да ли је облик `Rectangle` или `Circle` или `Triangle`. Декларирањем интерфејса помагач се одваја од конкретних типова и има само ону методу која му је потребна за обављање посла.

Овакав приступ коришћења интерфејса за декларисање **само онога што вам треба** веома је важан у дизајну софтвера и биће детаљније обрађен у наредним одељцима.

## Даља рефакторизација

Сад кад сте мало разумели структуре, можемо да уведемо „тестове вођене табелом“.

[Тестови вођени табелом](https://github.com/golang/go/wiki/TableDrivenTests) корисни су када желите да направите листу тест случајева који се могу тестирати на исти начин.

```go
func TestArea(t *testing.T) {

    areaTests := []struct {
        shape Shape
        want  float64
    }{
        {Rectangle{12, 6}, 72.0},
        {Circle{10}, 314.1592653589793},
    }

    for _, tt := range areaTests {
        got := tt.shape.Area()
        if got != tt.want {
            t.Errorf("got %g want %g", got, tt.want)
        }
    }

}
```

Једина нова синтакса овде је стварање "анонимне структуре", `areaTests`. Декларишемо комад структуре користећи `[]struct` са два поља, `shape` и `want`. Затим пунимо резање коферима.

Затим их пређемо, баш као и било који други пресек, користећи поља струцт за покретање тестова.

Можете видети како би програмеру било врло лако да уведе нови облик, примени `Area` и дода га у тест случајеве. Поред тога, ако се пронађе грешка у `Area`, врло је лако додати нови тест случај да бисте је вежбали пре него што је поправите.

Тестови вођени табелом могу бити сјајна ставка у вашем алату, али будите сигурни да вам је потребна додатна бука у тестовима.
Они се изврсно уклапају када желите да тестирате разне примене интерфејса или ако подаци који се преносе у функцију имају пуно различитих захтева које треба тестирати.

Покажимо све ово додавањем другог облика и тестирањем; троугао.

## Прво напишите тест

Додавање новог теста за наш нови облик је врло једноставно. Само додајте `{Triangle{12, 6}, 36.0},` на нашу листу.

```go
func TestArea(t *testing.T) {

    areaTests := []struct {
        shape Shape
        want  float64
    }{
        {Rectangle{12, 6}, 72.0},
        {Circle{10}, 314.1592653589793},
        {Triangle{12, 6}, 36.0},
    }

    for _, tt := range areaTests {
        got := tt.shape.Area()
        if got != tt.want {
            t.Errorf("got %g want %g", got, tt.want)
        }
    }

}
```

## Покушајте да покренете тест

Запамтите, и даље покушавајте да покренете тест и допустите да га преводилац води ка решењу.

## Напишите минималну количину кода за покретање теста и проверите неуспешне резултате теста

`./shapes_test.go:25:4: undefined: Triangle`

Још нисмо дефинисали `Triangle`

```go
type Triangle struct {
    Base   float64
    Height float64
}
```

Покушајте поново

```text
./shapes_test.go:25:8: cannot use Triangle literal (type Triangle) as type Shape in field value:
    Triangle does not implement Shape (missing Area method)
```

Говори нам да не можемо да користимо `Triangle` као облик, јер он нема методу `Area() `, па додајте празну имплементацију да би тест успео

```go
func (t Triangle) Area() float64 {
    return 0
}
```

Коначно се код компајлира и добијамо грешку

`shapes_test.go:31: got 0.00 want 36.00`

## Напишите довољно кода да прође

```go
func (t Triangle) Area() float64 {
    return (t.Base * t.Height) * 0.5
}
```

И наши тестови пролазе!

## Рефактор

Опет, примена је у реду, али наши тестови би могли да донесу одређено побољшање.

Када ово скенирате

```go
{Rectangle{12, 6}, 72.0},
{Circle{10}, 314.1592653589793},
{Triangle{12, 6}, 36.0},
```

Није одмах јасно шта представљају сви бројеви и требало би да циљате на то да ваши тестови буду лако разумљиви.

До сада вам је приказана синтакса само за креирање инстанци структура `MyStruct{val1, val2}`, али по жељи можете да именујете поља.

Да видимо како то изгледа

```go
        {shape: Rectangle{Width: 12, Height: 6}, want: 72.0},
        {shape: Circle{Radius: 10}, want: 314.1592653589793},
        {shape: Triangle{Base: 12, Height: 6}, want: 36.0},
```

У [Развој вођен тестом на примеру](https://g.co/kgs/yCzDLF) Кент Бек рефакторише неке тестове до тачке и тврди:

> Тест нам говори јасније, као да је реч о тврдњи истине, **а не о редоследу операција**

\(нагласак у цитату је мој\)

Сада наши тестови - тачније, листа тест случајева - дају тврдње о истини о облицима и њиховим областима.

## Уверите се да је тест резултат користан

Сећате ли се раније када смо имплементирали `Triangle` и имали смо неуспели тест? Приказано је `shapes_test.go:31: got 0.00 want 36.00`.

Знали смо да је то у вези са `Triangle` јер смо само радили с њим.
Али шта ако се грешка увукла у систем у једном од 20 случајева у табели?
Како би програмер могао знати који је случај пропао?
Ово није велико искуство за програмера, мораће ручно да прегледају случајеве како би сазнали који случај заправо није успео.

Своју поруку о грешци можемо променити у `%#v got %g want %g`. Низ формата `%#v` ће исписати нашу структуру са вредностима у свом пољу, тако да програмер може на први поглед да види својства која се тестирају.

Да бисмо додатно повећали читљивост наших тест случајева, можемо преименовати поље `want` у нешто описније попут` hasArea`.

Последњи савет за тестове вођене табелом је коришћење `t.Run` и именовање случајева примера.

Умотавањем сваког случаја у `t.Run` имат ћете јасније резултате теста о кваровима јер ће исписати име случаја

```text
--- FAIL: TestArea (0.00s)
    --- FAIL: TestArea/Rectangle (0.00s)
        shapes_test.go:33: main.Rectangle{Width:12, Height:6} got 72.00 want 72.10
```

А можете да покренете одређене тестове у оквиру своје табеле помоћу `go test -run TestArea/Rectangle`.

Ево нашег последњег тест кода који ово бележи

```go
func TestArea(t *testing.T) {

    areaTests := []struct {
        name    string
        shape   Shape
        hasArea float64
    }{
        {name: "Rectangle", shape: Rectangle{Width: 12, Height: 6}, hasArea: 72.0},
        {name: "Circle", shape: Circle{Radius: 10}, hasArea: 314.1592653589793},
        {name: "Triangle", shape: Triangle{Base: 12, Height: 6}, hasArea: 36.0},
    }

    for _, tt := range areaTests {
        // using tt.name from the case to use it as the `t.Run` test name
        t.Run(tt.name, func(t *testing.T) {
            got := tt.shape.Area()
            if got != tt.hasArea {
                t.Errorf("%#v got %g want %g", tt.shape, got, tt.hasArea)
            }
        })

    }

}
```

## Окончање

Ово је била више ТДД пракса, понављање наших решења за основне математичке проблеме и учење нових језичких карактеристика мотивисаних нашим тестовима.

* Изјава о структурама за креирање сопствених типова података што вам омогућава спајање повезаних података и јаснију намеру кода
* Декларисање интерфејса тако да можете дефинисати функције које могу користити различити типови \ ([параметарски полиморфизам](https://en.wikipedia.org/wiki/Parametric_polymorphism)\)
* Додавање метода тако да можете додати функционалност својим врстама података и тако имплементирати интерфејсе
* Тестови вођени табелом како би ваше тврдње биле јасније, а пакети тестова лакши за проширење и одржавање

Ово је било важно поглавље, јер сада почињемо да дефинишемо своје типове. У статички откуцаним језицима као што је Го, способност дизајнирања сопствених типова је од суштинске важности за изградњу софтвера који је лако разумљив, сложити и тестирати.

Интерфејси су одличан алат за скривање сложености од других делова система. У нашем случају наш тестни помагач _ВС КОД_ није морао да зна тачан облик на коме је полагао, већ само како да „пита“ за своје подручје.

Како се будете боље упознавали са Гоом, видећете стварну снагу интерфејса и стандардне библиотеке. Научићете о интерфејсима дефинисаним у стандардној библиотеци који се користе _свуда_ и примењујући их у односу на ваше типове, можете врло брзо поново да користите пуно сјајних функционалности.
